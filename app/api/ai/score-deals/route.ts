import { NextRequest, NextResponse } from "next/server";
import { GoogleGenerativeAI } from "@google/generative-ai";

interface SerializableGroupBuy {
  id: string;
  productName: string;
  pricePerKg: number;
  targetQuantity: number;
  currentQuantity: number;
  status: "open" | "closed" | "fulfilled";
  expiryDate: string;
  hubName: string;
}

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY!);

export async function POST(req: NextRequest) {
  try {
    const { deals, userProfile } = await req.json();

    if (!deals || !Array.isArray(deals) || !userProfile) {
      return NextResponse.json(
        { error: "Missing deals array or user profile" },
        { status: 400 }
      );
    }

    const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash" });

    // Prepare user context
    const userContext = `
User Profile:
- Business Type: ${userProfile.vendorProfile?.businessType || "Unknown"}
- Location: ${userProfile.vendorProfile?.location || "Unknown"}
- Daily Customers: ${userProfile.vendorProfile?.dailyCustomers || "Unknown"}
- Supplies Needed: ${
      userProfile.vendorProfile?.suppliesNeeded?.join(", ") || "None specified"
    }
- Business Description: ${
      userProfile.vendorProfile?.businessDescription || "None"
    }
    `;

    // Score each deal
    const scoredDeals = await Promise.all(
      deals.map(async (deal: SerializableGroupBuy) => {
        try {
          const prompt = `
You are an AI business advisor for street food vendors. Score this deal from 0-100 based on how well it matches the user's business needs and potential profitability.

${userContext}

Deal to Score:
- Product: ${deal.productName}
- Price per kg: â‚¹${deal.pricePerKg}
- Target Quantity: ${deal.targetQuantity}kg
- Current Quantity: ${deal.currentQuantity}kg
- Hub: ${deal.hubName}
- Progress: ${Math.round((deal.currentQuantity / deal.targetQuantity) * 100)}%

Consider these factors:
1. Relevance to user's business type and supplies needed (40%)
2. Price competitiveness and potential savings (25%)
3. Quantity suitability for their business size (20%)
4. Deal completion likelihood (15%)

Return ONLY a JSON object with this exact format:
{
  "score": 85,
  "reasoning": "High relevance to chaat business, competitive price, suitable quantity for daily customers, good completion likelihood"
}
          `;

          const result = await model.generateContent(prompt);
          const response = await result.response;
          const text = response.text();

          // Try to extract JSON from the response
          const jsonMatch = text.match(/\{[^}]*\}/);
          if (jsonMatch) {
            const scoreData = JSON.parse(jsonMatch[0]);
            return {
              ...deal,
              aiScore: Math.max(0, Math.min(100, scoreData.score || 0)),
              aiReasoning:
                scoreData.reasoning || "Score generated by AI analysis",
            };
          }
        } catch (error) {
          console.error(`Error scoring deal ${deal.id}:`, error);
        }

        // Fallback scoring based on simple heuristics
        let score = 50; // Base score

        // Check if product matches user's supplies needed
        if (
          userProfile.vendorProfile?.suppliesNeeded?.some(
            (supply: string) =>
              deal.productName.toLowerCase().includes(supply.toLowerCase()) ||
              supply.toLowerCase().includes(deal.productName.toLowerCase())
          )
        ) {
          score += 30;
        }

        // Boost score based on deal progress (more likely to complete)
        const progress = (deal.currentQuantity / deal.targetQuantity) * 100;
        if (progress > 70) score += 10;
        else if (progress > 40) score += 5;

        // Price consideration (lower prices get higher scores)
        if (deal.pricePerKg < 50) score += 10;
        else if (deal.pricePerKg < 100) score += 5;

        return {
          ...deal,
          aiScore: Math.max(0, Math.min(100, score)),
          aiReasoning:
            "Scored based on business relevance and deal characteristics",
        };
      })
    );

    // Sort by AI score (highest first)
    scoredDeals.sort((a, b) => (b.aiScore || 0) - (a.aiScore || 0));

    return NextResponse.json({ scoredDeals });
  } catch (error) {
    console.error("Error scoring deals:", error);
    return NextResponse.json(
      { error: "Failed to score deals" },
      { status: 500 }
    );
  }
}
